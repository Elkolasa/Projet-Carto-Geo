<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Livre en ligne</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
        font-family: sans-serif;
        background-color: #f2f2f2;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
    }

    .book-container {
        width: 80vw;
        max-width: 600px;
        aspect-ratio: 210 / 297;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }

    .page {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 100%; /* hors écran par défaut */
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        transition: left 0.5s ease;
    }

    .page.active { left: 0; }
    .page.prev { left: -100%; }
    .page.next { left: 100%; }
</style>
</head>
<body>

<div class="book-container">
    <div class="page active" style="background-image: url('Images/Couverture.png');"></div>
    <div class="page" style="background-image: url('Images/page2.png');"></div>
    <div class="page" style="background-image: url('Images/page3.png');"></div>
    <div class="page" style="background-image: url('Images/page4.png');"></div>
</div>

<script>
const pages = document.querySelectorAll('.page');
let currentIndex = 0;

function showPage(nextIndex) {
    if(nextIndex === currentIndex) return;
    const direction = nextIndex > currentIndex ? 'next' : 'prev';

    pages.forEach((p, i) => {
        p.classList.remove('active','prev','next');
        if(i === currentIndex){
            p.classList.add(direction === 'next' ? 'prev' : 'next'); // ancienne page sort opposé au mouvement
        }
        if(i === nextIndex) p.classList.add('active'); // nouvelle page active
    });

    currentIndex = nextIndex;
}

// Scroll / wheel
let isScrolling = false;
window.addEventListener('wheel', e => {
    if (isScrolling) return;
    isScrolling = true;
    if(e.deltaY > 0 && currentIndex < pages.length - 1) showPage(currentIndex + 1);
    else if(e.deltaY < 0 && currentIndex > 0) showPage(currentIndex - 1);
    setTimeout(() => isScrolling = false, 600);
});

// Swipe tactile
let touchStartX = 0;
window.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
window.addEventListener('touchend', e => {
    const touchEndX = e.changedTouches[0].clientX;
    const diff = touchStartX - touchEndX;
    if(diff > 50 && currentIndex < pages.length - 1) showPage(currentIndex + 1);
    else if(diff < -50 && currentIndex > 0) showPage(currentIndex - 1);
});

// Flèches clavier
window.addEventListener('keydown', e => {
    if(e.key === 'ArrowRight' && currentIndex < pages.length - 1) showPage(currentIndex + 1);
    if(e.key === 'ArrowLeft' && currentIndex > 0) showPage(currentIndex - 1);
});

// Zoom tactile
pages.forEach(page => {
    let scale = 1;
    let lastDistance = null;
    page.addEventListener('touchmove', e => {
        if(e.touches.length === 2){
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx*dx + dy*dy);
            if(lastDistance){
                const diff = distance - lastDistance;
                scale += diff * 0.005;
                scale = Math.max(0.5, Math.min(scale, 3));
                page.style.transform = `scale(${scale})`;
            }
            lastDistance = distance;
        }
    });
    page.addEventListener('touchend', e => { if(e.touches.length < 2) lastDistance = null; });
});

// Initial
showPage(currentIndex);
</script>

</body>
</html>

